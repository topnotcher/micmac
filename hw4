main:
	; load the address of the root node 
	LOCO root

	; dbg_print ac

	; PUSH address of root node onto stack.
	PUSH

	; Allocate space for return value.
	PUSH

	CALL count

	; pop off the return value.
	POP

	; store it in result 
	STOD result 

	done: JUMP done ; dbg_print result
	
count:
	; stack:
	; 0 return addr 
	; 1 return value
	; 2 arg

	LOCO 1 
	; set return value to 1 (count this node)
	STOL 1 

	; if there's a left branch, add its size
	; to the return value
	check_left:
	
		; load the argument
		LODL 2
		
		;dbg_print ac

		; ac contains the address of the address of a node, e.g.
		; M[AC] = node value
		; M[AC+1] = address of left branch
		; M[AC+2] = address of right branch

		; now M[AC] = address of left branch.
		ADDD one 
		
		;dbg_print ac

		; PSHI => M[++SP] = M[AC]
		PSHI 

		; now pop off
		POP

		; AC = address of left branch

		; dbg_print ac
		JNZE add_left

	; likewise for the right
	; (jumped here from add_left or did not jump TO add_left)
	check_right:
		LODL 2

		;dbg_print ac
		ADDD two

		PSHI
		
		POP

		;dbg_print ac

		JNZE add_right 

	
	; else return 
	RETN  

	; prior to jumping to either
	; add_left or add_right,
	; AC = the address of the node to check
	add_left:
		
		; PUSH the address onto the stack 
		PUSH

		; Allocate space for return value
		PUSH

		CALL count
	
		; POP the return value off
		POP
		
		; deallocate space used for the arg.
		INSP 1

		; add it to this FN's return value.
		ADDL 1 
	
		; Store it back in the return value.
		STOL 1

		; now check the right.
		JUMP check_right

	add_right: 
		
		; called ra
		; called rv 
		; called arg
		; my ra
 		; my rv
		; my arg 

		; PUSH the address onto the stack 
		PUSH

		; Allocate space for return value
		PUSH

		CALL count
	
		; POP the return value off
		POP

		; sp = called arg

		; deallocate space used for the arg
		INSP 1

		; add it to this FN's return value.
		ADDL 1 
	
		; Store it back in the return value.
		STOL 1

		; dbg_print AC

	RETN


one: DEFN 1
two: DEFN 2
result: DEFN 0

; a test binary tree
root:
	DEFN 1
	DEFN node2
	DEFN node3

; left branch.
node2:
	DEFN 1
	DEFN node4
	DEFN node5

; right branch.
node3: 
	DEFN 1
	DEFN node6
	DEFN node7

node4: 
	DEFN 1
	DEFN 0
	DEFN 0

node5: 
	DEFN 1
	DEFN 0
	DEFN 0

node6: 
	DEFN 1
	DEFN 0
	DEFN 0

node7: 
	DEFN 1
	DEFN 0
	DEFN 0


